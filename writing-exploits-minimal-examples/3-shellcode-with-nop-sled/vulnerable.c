#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* This is my first buffer overrun exploit where I wrote both the
 * vulnerable code and the exploit entirely from scratch, using only gdb
 * and and waffling. The vulnerability in this program's binary can
 * be exploited by running it with:
 *
 * ./vulnerable $(perl -e 'print "A" x 30')
 * 
 * which lets us "log in" even when we don't have the right password.
 * 
 * However, I had kinda done that before in my own programs.
 * The really cool thing is the following:
 * 
 * Running the program with:
 * 
 * ./vulnerable $(perl -e 'print "A" x 40 . "\xf2\x06\x40\x00"')
 *
 * causes the return from check_authorization to jump into
 * a section of the code that should be impossible to enter, namely
 * the infinite loop that prints "What is this?\nI do not even!\n"
 * Baller!
 */

int check_authorization(char *password)
{
    int auth = 0;
    char pw_buf[100];
    printf("pw_buf @ 0x%08x\n", pw_buf);
    strcpy(pw_buf, password);
    if (strcmp(pw_buf, "supersecret") == 0)
        auth = 1;

    return auth;
}

int main(int argc, char *argv[])
{
    int auth;

    if (argc == 1) {
        fprintf(stderr, "Usage: %s <password>\n", argv[0]); 
        exit(-1);
    }

    /* Should be impossible to get in here, but we execute it anyway! */
    if (argc == 1) {
        while (1) {
            printf("What is this?\n");
            printf("I do not even!\n");
        }
    }

    // printf("Ready to check authorization!\n");

    auth = check_authorization(argv[1]);

    if (auth)
        printf("Login successful!\n");
    else
        printf("Login failure...\n");

    return 0;
}

